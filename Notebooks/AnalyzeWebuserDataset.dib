#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp","aliases":["c#","C#"],"languageName":"C#"},{"name":"sql","languageName":"SQL","aliases":[]},{"name":"vscode","aliases":["frontend"],"languageName":null},{"name":"mermaid","languageName":"Mermaid","aliases":[]}]}}

#!csharp

#r "nuget: Microsoft.ML"
#r "nuget: Microsoft.Data.Analysis"
#r "nuget: Microsoft.DotNet.Interactive.ExtensionLab,*-*"

#r "nuget: Plotly.NET"
#r "nuget: Plotly.NET.Interactive"

#r "nuget: CsvHelper"

using Microsoft.Data.Analysis;
using Microsoft.ML;
using Microsoft.ML.Data;

using Plotly.NET;
using Plotly.NET.Interactive;

using CsvHelper;

using System;
using System.IO;
using System.Text;
using System.Text.Json;
using System.Linq;

#!csharp

using System.Globalization;
static void WriteToCsv<T>(this IEnumerable<T> records, string filename)
{
    using (var writer = new StreamWriter(filename)) {
        using (var csv = new CsvWriter(writer, CultureInfo.InvariantCulture)) {
            csv.WriteRecords(records);
        }
    }
}

#!csharp

using System.Net;

public record ObservableEvent<TPayload>(DateTime StartTime,DateTime EndTime,TPayload Payload);

public record IpSimpleHostContext(IPAddress HostAddress, string OperatingSystem, IpConnectionInfo[] InitiatedConnections, IpConnectionInfo[]AcceptedConnections, ResolvedDomainInfo[] ResolvedDomains, WebRequestInfo[] WebUrls, TlsConnectionInfo[] Secured);

public record IpConnectionInfo(IPAddress RemoteHostAddress, string RemoteHostName, ushort RemotePort, string Service, int Flows, int PacketsSent, int OctetsSent, int PacketsRecv, int OctetsRecv);

public record WebRequestInfo(IPAddress RemoteHostAddress, string RemoteHostName, ushort RemotePort, string ApplicationProcessName, string Method, string Url);

public enum DnsResponseCode { NoError = 0, FormErr = 1, ServFail = 2, NXDomain = 3, NotImp = 4, Refused = 5, YXDomain = 6, YXRRSet = 7,
        NXRRSet = 8, NotAuth = 9, NotZone = 10, BadVers = 16 }

public record ResolvedDomainInfo(IPAddress DnsServer, string QueryString, string ResponseData, DnsResponseCode ResponseCode);

public record TlsConnectionInfo(IPAddress RemoteHostAddress, string RemoteHostName, ushort RemotePort, string ApplicationProcessName, string ApplicationProtocol, string ServerNameIndication, string JA3Fingerprint, string IssuerName, string SubjectName, string OrganisationName);

public class IPAddressConverter : System.Text.Json.Serialization.JsonConverter<IPAddress>
{
        public override IPAddress Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                string ipAddressString = reader.GetString();
                return IPAddress.Parse(ipAddressString);
        }

        public override void Write(Utf8JsonWriter writer, IPAddress value, JsonSerializerOptions options)
        {
                writer.WriteStringValue(value.ToString());
        }
}

var jsonOptions = new JsonSerializerOptions();
jsonOptions.Converters.Add(new IPAddressConverter());

#!markdown

# Load source data

The JSON files stored in ..\TestData\tor-context are the source datasets in this analysis. Each file contains lines of JSON objects. 


See the tutorial on how to load and inspect data: https://rubikscode.net/2021/09/27/net-interactive-jupyter-notebooks/

#!csharp

var items = File.ReadAllLines(@$"e:\Ethanol\webuser2\webuser.ctx.json");
// get context only for the selected host:
var host = items
     .Select(x => JsonSerializer.Deserialize<ObservableEvent<IpSimpleHostContext>>(x, jsonOptions))
     .Where(x=>x.Payload.HostAddress.ToString()=="192.168.111.19");

var tls = host.SelectMany(x=>x.Payload.Secured);

#!markdown

## Detect Tor group of flows

GOAL: Be able to classify the entire bag-of-ja3-flows as Tor/Non-Tor connections.

QUESTION: What methods to use for this?

ELABORATION:
Visually, it is very easy to distinguihes as the Tor flows are quite uniform. Only SNI is present nor other names, ports are {443, 9001, 5353}, there is not DNS translation leading to IP address of the Tor node.

No other group of flows has the same characteristic.

#!csharp

var tlsbrief = tls.Select(t=> new {App = t.ApplicationProcessName, Jas3 = t.JA3Fingerprint, Host = t.RemoteHostName, Sni = t.ServerNameIndication, Subject =t.SubjectName}).ToList();
tlsbrief.WriteToCsv("app_named.csv");

tlsbrief.Where(x=>x.Sni?.Contains("tiktok")??false).WriteToCsv("tiktok.csv");

tlsbrief.Where(x=>x.Sni?.Contains("insta")??false).WriteToCsv("instagram.csv");

tlsbrief.Where(x=>x.App == "chrome").WriteToCsv("chrome.csv");

tlsbrief.Where(x=>x.App == "msedge").WriteToCsv("msedge.csv");

tlsbrief.Where(x=>x.App == "firefox").WriteToCsv("firefox.csv");

tlsbrief.Where(x=>x.App == "tor").WriteToCsv("tor.csv");

tlsbrief.Where(x=>x.App == "Spotify").WriteToCsv("spotify.csv");


tlsbrief.Where(x=>x.App == "Zoom").WriteToCsv("zoom.csv");

// Can we link different JA3 groups by host/sni ??
