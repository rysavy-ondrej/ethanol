#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Malware's IoC Analysis

This notebook presents a systematic approach to analyze and characterize Malware Indicators of Compromise (IoCs) for selected families, aiming to identify the most significant IoCs that define each family's unique footprint. The methodology encompasses a multi-step process, beginning with the meticulous collection and standardization of IoC data, including URLs, Domains, and IPs, obtained from approximately ten samples per family via Tria.ge. An exploratory analysis is conducted to assess the frequency and variability of these IoCs within each family, providing a preliminary understanding of their characteristics. 

#!csharp

#r "nuget: Microsoft.ML"
#r "nuget: Microsoft.Data.Analysis"
#r "nuget: Microsoft.DotNet.Interactive.ExtensionLab,*-*"

#r "nuget: CsvHelper"
#r "nuget: ScottPlot"

#r "../Source/Ethanol.MalwareSonar/bin/Debug/net7.0/Ethanol.MalwareSonar.dll"

using Microsoft.Data.Analysis;
using Microsoft.ML;
using Microsoft.ML.Data;
using System.IO;
using System.Text.Json;

using CsvHelper;
using ScottPlot;

using Ethanol.MalwareSonar;

// Setup a custom formatter to display plots as images
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHTML()), HtmlFormatter.MimeType);

#!markdown

## 1. Data Collection and Preparation

### 1.1 Gather IoC Data
The IoCs (URLs, Domains, IPs) from Tria.ge for each of the malware families are collected in `TestData/MalwareSonar` folder. There are two subfolders for Trainign and Testing collecitons, respectively.

### 1.2 Standardize Data Format
The data are represented uniformly in a dictionary for ease of analysis. Iocs data structures consists of lists of URLs, Domains, and IPs. 

#!csharp

var rootDataFolder = @"../TestData/MalwareSonar/";
var TrainFolder = Path.Combine(rootDataFolder, "Train");

var sourceData = new Dictionary<string, List<MalwareIocs>>();

// load from this folder all samples to dictionary
var families = Directory.GetDirectories(TrainFolder);


record MalwareIocs(string Family, string SampleId, Uri[] Urls, string[] Domains, string[] Ips);

MalwareIocs NormalizeIocs(string family, string sampleId, Ethanol.MalwareSonar.MalwareReport.Iocs source)
{
    return new MalwareIocs
    (
        family, 
        sampleId, 
        source.Urls ?? Array.Empty<Uri>(),
        source.Domains ?? Array.Empty<string>(),
        source.Ips ?? Array.Empty<string>()
    );
}


foreach(var family in families)
{
    var familyName = Path.GetFileName(family);
    var samples = Directory.GetFiles(family);
    var iocs = new List<MalwareIocs>();
    foreach(var sample in samples)
    {
        var report = JsonSerializer.Deserialize<Ethanol.MalwareSonar.MalwareReport.Report>(File.ReadAllText(sample));
        var sampleIocs = report.Targets?.Select(t=>NormalizeIocs(familyName,report.Sample.Id, t.Iocs)) ?? Enumerable.Empty<MalwareIocs>();
        iocs.AddRange(sampleIocs);
    }
    sourceData[familyName] = iocs;
}

sourceData.Display();

#!markdown

## 2. Exploratory Analysis

The exploratory analysis phase of the Malware IoC (Indicators of Compromise) characterization process involved a detailed examination of IoC data, which included URLs, Domains, and IPs from selected malware families. 

#!markdown

### 2.1 Initial Examination

Conduct a preliminary analysis to understand the general characteristics of the IoCs for each family. For each family we just compute some basic statistics about IoCs distribution among samples.

#!csharp

foreach(var family in sourceData)
{
    var samples = family.Value.Count();
    Console.WriteLine($"{family.Key}: samples={samples}");
    
    var domains = family.Value.Sum(x=>x.Domains.Count());
    var urls = family.Value.Sum(x=>x.Urls.Count());
    var ips = family.Value.Sum(x=>x.Ips.Count());
    Console.WriteLine($"  total urls={urls}, domains={domains}, ips={ips}");

    var uniqueDomains = family.Value.SelectMany(x=>x.Domains).Distinct().Count();
    var uniqueUrls = family.Value.SelectMany(x=>x.Urls).Distinct().Count();
    var uniqueIps = family.Value.SelectMany(x=>x.Ips).Distinct().Count();
    Console.WriteLine($"  unique urls={uniqueUrls}, domains={uniqueDomains}, ips={uniqueIps}");

    var avgDomains = family.Value.Average(x=>x.Domains.Count());
    var avgUrls = family.Value.Average(x=>x.Urls.Count());
    var avgIps = family.Value.Average(x=>x.Ips.Count());
    Console.WriteLine($"  average urls={avgUrls}, domains={avgDomains}, ips={avgIps}");
   
    var minDomains = family.Value.Min(x=>x.Domains.Count());
    var minUrls = family.Value.Min(x=>x.Urls.Count());
    var minIps = family.Value.Min(x=>x.Ips.Count());
    Console.WriteLine($"  min urls={minUrls}, domains={minDomains}, ips={minIps}");
    
    var maxDomains = family.Value.Max(x=>x.Domains.Count());
    var maxUrls = family.Value.Max(x=>x.Urls.Count());
    var maxIps = family.Value.Max(x=>x.Ips.Count());
    Console.WriteLine($"  max urls={maxUrls}, domains={maxDomains}, ips={maxIps}");
}

#!markdown

### 2.2 Frequency Analysis

Determine the frequency of each IoC within a family. This helps identify the most common IoCs in each family.

#!csharp

foreach(var family in sourceData)
{
    var samples = family.Value.Count();
    Console.WriteLine($"{family.Key}: samples={samples}");
    
    var urls = family.Value.SelectMany(x=>x.Urls).GroupBy(x=>x, x=>x, (k,v) => (Key: k, Freq: v.Count() / (float)samples)).OrderByDescending(x=>x.Freq);
    urls.Display();

    var domains = family.Value.SelectMany(x=>x.Domains).GroupBy(x=>x, x=>x, (k,v) => (Key: k, Freq: v.Count() / (float)samples)).OrderByDescending(x=>x.Freq);
    domains.Display();

    var ips = family.Value.SelectMany(x=>x.Ips).GroupBy(x=>x, x=>x, (k,v) => (Key: k, Freq: v.Count() / (float)samples)).OrderByDescending(x=>x.Freq);
    ips.Display();
}

#!markdown

### 2.3 Variability Assessment
Assess the variability of IoCs within each family. Understanding the range and diversity of IoCs can provide insights into the behavior and evolution of the malware.

#!csharp

foreach(var family in sourceData)
{
    var plt = new ScottPlot.Plot(600, 400);
    plt.Display();
}

#!markdown

## 3. Similarity and Difference Analysis

3.1 Intra-Family Analysis: Within each family, analyze the IoCs to identify common patterns or unique outliers.

3.2 Cross-Family Comparison: Compare IoCs across different families to find any commonalities or distinct features. This might reveal shared infrastructure or tactics among different malware families.

#!markdown

## 4. Significance Assessment

4.1 Rank IoCs by Relevance: Develop a method to rank IoCs based on their significance. This could involve weighting factors like frequency of occurrence, uniqueness to a family, and potential impact.

4.2 Use Fuzzy Logic for Handling Ambiguities: Given the nuances and variations in IoCs, employing fuzzy logic can help in assessing the significance of IoCs by dealing with the partial truths and uncertainties.

#!markdown

## 5. Characterization of Malware Families

5.1 Create IoC Profiles: Develop a profile for each malware family based on the most significant IoCs. This profile would include a set of IoCs that are highly representative of each family.

5.2 Visualization: Use graphical representations, like heatmaps or cluster diagrams, to visually illustrate the relationship and significance of IoCs within and across families.
