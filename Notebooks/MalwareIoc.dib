#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Malware's IoC Analysis

## Abstract

In this study, we introduce a systematic methodology for analyzing and characterizing Malware Indicators of Compromise (IoCs) for selected families. Our objective is to pinpoint the most significant IoCs that uniquely define each family's behavioral pattern. This involves an intricate process starting from the detailed collection and standardization of IoC data, encompassing URLs, Domains, and IPs. The data is meticulously gathered from approximately ten samples per malware family, utilizing the Tria.ge platform. An initial exploratory analysis is undertaken to evaluate the frequency and variability of these IoCs, offering an initial insight into their distinct characteristics and patterns.

## Introduction

The core concept of this research revolves around the detection of malware activities through the identification and analysis of known IoCs. These IoCs are derived from in-depth malware analyses conducted in controlled sandbox environments. Our approach is centered around the creation of a malware communication profile based on these IoCs, which is then employed to scrutinize monitored communication channels for potential threats. 

This research employs fuzzy set theory to achieve an approximate yet insightful characterization of the malware communication profile. By embracing the principles of fuzzy logic, we aim to handle the inherent ambiguities and uncertainties present in the IoCs, allowing for a more nuanced and comprehensive understanding of malware behaviors.

The process of obtaining and processing IoCs is delineated as follows:

- **IoC Acquisition**: IoCs are extracted from the Tria.ge analysis of malware samples, which are sourced from MalwareBazaar (abuse.ch).
- **Sample Representation**: Each malware family is represented by a collection of dozens of samples, ensuring a robust and diverse dataset.
- **Individual Analysis**: Every sample is analyzed individually, leading to a compilation of IoCs.
- **IoC Collection Composition**: The resulting IoC collection encompasses various elements, including URLs from HTTP requests initiated by the malware, domain names resolved during its operation, and IP addresses of hosts contacted by the malware.

### Prerequisites

To facilitate this analysis, specific prerequisites are essential:

1. **Comprehensive Malware Samples**: A diverse range of malware samples from various families to ensure a representative dataset.
2. **Analysis Tools**: Access to advanced malware analysis tools like Tria.ge for detailed IoC extraction.
3. **Fuzzy Logic Framework**: An established framework for applying fuzzy set theory to the analysis of IoCs.
4. **Data Processing Capabilities**: Robust data processing and analysis capabilities to handle large volumes of IoC data.

Through this methodical approach, we aim to enhance the understanding of malware activities, offering valuable insights into their communication patterns and contributing significantly to the field of cybersecurity.

#!csharp

//#r "nuget: Microsoft.ML"
//#r "nuget: Microsoft.Data.Analysis"
//#r "nuget: Microsoft.DotNet.Interactive.ExtensionLab,*-*"

#r "nuget: CsvHelper"
#r "nuget: ScottPlot"

#r "../Source/Ethanol.ContextBuilder/bin/Debug/net7.0/Ethanol.ContextBuilder.dll"
#r "../Source/Ethanol.MalwareSonar/bin/Debug/net7.0/Ethanol.MalwareSonar.dll"

//using Microsoft.Data.Analysis;
//using Microsoft.ML;
//using Microsoft.ML.Data;
using System.IO;
using System.Text.Json;

using CsvHelper;
using ScottPlot;

using Ethanol.MalwareSonar;

// Setup a custom formatter to display plots as images
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHTML()), HtmlFormatter.MimeType);


record PlotRow(Plot[] Plots);

Formatter.Register(typeof(PlotRow), (p, w) => {
    var html = "<table><tr><td>" + String.Join("</td><td>",((PlotRow)p).Plots.Select(p=> p.GetImageHTML())) + "</td></tr></table>";
    w.Write(html); }, HtmlFormatter.MimeType);

#!markdown

## 1. Data Collection and Preparation

### 1.1 Gather IoC Data
The IoCs (URLs, Domains, IPs) from Tria.ge for each of the malware families are collected in `TestData/MalwareSonar` folder. There are two subfolders for Trainign and Testing collecitons, respectively.

### 1.2 Standardize Data Format
The data are represented uniformly in a dictionary for ease of analysis. Iocs data structures consists of lists of URLs, Domains, and IPs. 

#!csharp

var rootDataFolder = @"../TestData/MalwareSonar/";
var TrainFolder = Path.Combine(rootDataFolder, "Train");

var sourceData = new Dictionary<string, List<MalwareIocs>>();

// load from this folder all samples to dictionary
var families = Directory.GetDirectories(TrainFolder);


record MalwareIocs(string Family, string SampleId, Uri[] Urls, string[] Domains, string[] Ips);

MalwareIocs NormalizeIocs(string family, string sampleId, Ethanol.MalwareSonar.MalwareReport.Iocs source)
{
    return new MalwareIocs
    (
        family, 
        sampleId, 
        source.Urls ?? Array.Empty<Uri>(),
        source.Domains ?? Array.Empty<string>(),
        source.Ips ?? Array.Empty<string>()
    );
}


foreach(var family in families)
{
    var familyName = Path.GetFileName(family);
    var samples = Directory.GetFiles(family);
    var iocs = new List<MalwareIocs>();
    foreach(var sample in samples)
    {
        var report = JsonSerializer.Deserialize<Ethanol.MalwareSonar.MalwareReport.Report>(File.ReadAllText(sample));
        var sampleIocs = report.Targets?.Select(t=>NormalizeIocs(familyName,report.Sample.Id, t.Iocs)) ?? Enumerable.Empty<MalwareIocs>();
        iocs.AddRange(sampleIocs);
    }
    sourceData[familyName] = iocs;
}

sourceData.Display();

#!markdown

## 2. Exploratory Analysis

The exploratory analysis phase of the Malware IoC (Indicators of Compromise) characterization process involved a detailed examination of IoC data, which included URLs, Domains, and IPs from selected malware families. 

#!markdown

### 2.1 Initial Examination

Conduct a preliminary analysis to understand the general characteristics of the IoCs for each family. For each family we just compute some basic statistics about IoCs distribution among samples.

#!csharp

foreach(var family in sourceData)
{
    var samples = family.Value.Count();
    Console.WriteLine($"{family.Key}: samples={samples}");
    
    var domains = family.Value.Sum(x=>x.Domains.Count());
    var urls = family.Value.Sum(x=>x.Urls.Count());
    var ips = family.Value.Sum(x=>x.Ips.Count());
    Console.WriteLine($"  total urls={urls}, domains={domains}, ips={ips}");

    var uniqueDomains = family.Value.SelectMany(x=>x.Domains).Distinct().Count();
    var uniqueUrls = family.Value.SelectMany(x=>x.Urls).Distinct().Count();
    var uniqueIps = family.Value.SelectMany(x=>x.Ips).Distinct().Count();
    Console.WriteLine($"  unique urls={uniqueUrls}, domains={uniqueDomains}, ips={uniqueIps}");

    var avgDomains = family.Value.Average(x=>x.Domains.Count());
    var avgUrls = family.Value.Average(x=>x.Urls.Count());
    var avgIps = family.Value.Average(x=>x.Ips.Count());
    Console.WriteLine($"  average urls={avgUrls}, domains={avgDomains}, ips={avgIps}");
   
    var varDomains = Math.Sqrt(family.Value.Sum(x=> (x.Domains.Count()-avgDomains) * (x.Domains.Count()-avgDomains))/ (float)samples);
    var varUrls = Math.Sqrt(family.Value.Sum(x=> (x.Urls.Count()-avgUrls) * (x.Urls.Count()-avgUrls))/ (float)samples);
    var varIps = Math.Sqrt(family.Value.Sum(x=> (x.Ips.Count()-avgIps) * (x.Ips.Count()-avgIps))/ (float)samples);
    Console.WriteLine($"  variance urls={varUrls}, domains={varDomains}, ips={varIps}");


    var minDomains = family.Value.Min(x=>x.Domains.Count());
    var minUrls = family.Value.Min(x=>x.Urls.Count());
    var minIps = family.Value.Min(x=>x.Ips.Count());
    Console.WriteLine($"  min urls={minUrls}, domains={minDomains}, ips={minIps}");
    
    var maxDomains = family.Value.Max(x=>x.Domains.Count());
    var maxUrls = family.Value.Max(x=>x.Urls.Count());
    var maxIps = family.Value.Max(x=>x.Ips.Count());
    Console.WriteLine($"  max urls={maxUrls}, domains={maxDomains}, ips={maxIps}");
}

#!markdown

### 2.2 Frequency Analysis

Determine the frequency of each IoC within a family. This helps identify the most common IoCs in each family.

#!csharp

foreach(var family in sourceData)
{
    var samples = family.Value.Count();
    Console.WriteLine($"{family.Key}: samples={samples}");
    
    var urls = family.Value.SelectMany(x=>x.Urls).GroupBy(x=>x, x=>x, (k,v) => (Key: k, Freq: v.Count() / (float)samples)).OrderByDescending(x=>x.Freq);
    urls.Display();

    var domains = family.Value.SelectMany(x=>x.Domains).GroupBy(x=>x, x=>x, (k,v) => (Key: k, Freq: v.Count() / (float)samples)).OrderByDescending(x=>x.Freq);
    domains.Display();

    var ips = family.Value.SelectMany(x=>x.Ips).GroupBy(x=>x, x=>x, (k,v) => (Key: k, Freq: v.Count() / (float)samples)).OrderByDescending(x=>x.Freq);
    ips.Display();
}

#!markdown

### 2.3 Variability Assessment
Assess the variability of IoCs within each family. By analyzing the frequency of each IoC (i.e., how many times it appears across different samples), we can gain insights into the commonality or rarity of specific IoCs within a family. 
It can help us to identify:

* High-Frequency IoCs: IoCs that appear in most samples are likely integral to the malware's operation. They could be key domains, IP addresses, or URLs the malware regularly communicates with.
* Low-Frequency IoCs: IoCs that appear only in a few samples could indicate specialized functions or adaptations to specific environments or targets. They could also represent evolutionary changes in the malware.

#!csharp

foreach(var family in sourceData)
{
    var samples = family.Value.Count();
   
    var urls = family.Value.SelectMany(x=>x.Urls).GroupBy(x=>x, x=>x, (k,v) => (Key: k, Count: v.Count()));
    var domains = family.Value.SelectMany(x=>x.Domains).GroupBy(x=>x, x=>x, (k,v) => (Key: k, Count: v.Count()));
    var ips = family.Value.SelectMany(x=>x.Ips).GroupBy(x=>x, x=>x, (k,v) => (Key: k, Count: v.Count()));

    var xs = Enumerable.Range(1,samples).ToList();
    var ys1 = xs.Select(y => urls.Where(x=>x.Count == y).Count());
    var ys2 = xs.Select(y => domains.Where(x=>x.Count == y).Count());
    var ys3 = xs.Select(y => ips.Where(x=>x.Count == y).Count());

    var xsd = xs.Select(x=>(double)x).ToArray();

    var plt1 = new ScottPlot.Plot(300, 300);
    plt1.Title($"{family.Key} urls");
    plt1.XLabel("freq"); plt1.YLabel("iocs");
    plt1.PlotBar(xsd, ys1.Select(y=>(double)y).ToArray());
    
    var plt2 = new ScottPlot.Plot(300, 300);
    plt2.Title($"{family.Key} domains");
    plt2.XLabel("freq"); plt2.YLabel("iocs");
    plt2.PlotBar(xsd, ys2.Select(y=>(double)y).ToArray());

    var plt3 = new ScottPlot.Plot(300, 300);
    plt3.Title($"{family.Key} ips");
    plt3.XLabel("freq"); plt3.YLabel("iocs");
    plt3.PlotBar(xsd, ys3.Select(y=>(double)y).ToArray());
    
    var pg = new PlotRow(new []{ plt1, plt2, plt3 }).Display();
}

#!markdown

## 3. Similarity and Difference Analysis

The Similarity and Difference Analysis is a critical phase that involves comparing and contrasting IoCs within and across malware families. This analysis aims to identify unique and common attributes, enhancing the understanding of each family's behavior and tactics.

#!markdown

## 3.1 Intra-Family Analysis

Within each family, we analyze the IoCs to identify common patterns or unique outliers. It is based on the previous analysis and the result is a fuzzy set of IoCs that characterize the malware family.

**Fuzzy Set Creation:** In these sets, IoCs (like URLs, domains, IPs) are the elements, and their degrees of membership are determined based on their relevance or frequency in the malware data. For instance, a frequently occurring domain in a malware family might have a high degree of membership in that family's fuzzy set.

#!csharp

using Ethanol.MalwareSonar.Fuzzy;

var fuzzySets = new Dictionary<string, FuzzySet<string>>();
foreach(var family in sourceData)
{
    var samples = family.Value.Count();
    Console.WriteLine($"{family.Key}: samples={samples}");
    
    var urlsFreq = family.Value.SelectMany(x=>x.Urls).GroupBy(x=>x, x=>x, (k,v) => new KeyValuePair<string,int>(k.ToString(),v.Count()) );
    
    var domainsFreq = family.Value.SelectMany(x=>x.Domains).GroupBy(x=>x, x=>x, (k,v) => new KeyValuePair<string,int>(k,v.Count()) );
    
    var ipsFreq = family.Value.SelectMany(x=>x.Ips).GroupBy(x=>x, x=>x, (k,v) => new KeyValuePair<string,int>(k,v.Count()) );

    var urlsFs = new FuzzySet<string>(new FrequencyBasedMembership<string>(urlsFreq, 0, samples), urlsFreq.Select(x=>x.Key));
    var domainsFs = new FuzzySet<string>(new FrequencyBasedMembership<string>(domainsFreq, 0, samples), domainsFreq.Select(x=>x.Key));
    var ipsFs = new FuzzySet<string>(new FrequencyBasedMembership<string>(ipsFreq, 0, samples), ipsFreq.Select(x=>x.Key));

    fuzzySets.Add($"{family.Key}.Urls", urlsFs);
    fuzzySets.Add($"{family.Key}.Domains", domainsFs);
    fuzzySets.Add($"{family.Key}.Ips", ipsFs);
}
fuzzySets.Display();

#!markdown

## 3.2 Cross-Family Comparison

Comparing IoCs (Indicators of Compromise) across different malware families to find commonalities or distinct features is a crucial step in cybersecurity analysis. This comparison can unveil shared patterns or behaviors among various malware types, which might indicate a common source, shared infrastructure, or similar tactics employed by different threat actors. Using computed fuzzy sets for this purpose adds a layer of sophistication to the analysis, allowing for more nuanced and flexible interpretation of the data.

### Analysis of Commonalities:

**Intersection of Fuzzy Sets:** Use fuzzy set operations (like T-norms) to find intersections between the fuzzy sets of different malware families. This can highlight IoCs that are common across families.

**Degree of Membership:** Examine the degree of membership of these common IoCs. A high degree of membership in multiple sets might indicate significant shared tactics or infrastructure.

#!csharp

public static void PlotIntersections(this IEnumerable<(string,FuzzySet<string>)> source)
{
    var plts = source.Select(x =>
    {    
        var vals = x.Item2.Members.Select(v => (key: v,val: x.Item2.GetMembership(v))).OrderByDescending(t => t.val).Select((x,i)=>(idx: (double)i, key: x.key, val: x.val)).ToArray();


        var plt = new ScottPlot.Plot(800, 800);
        plt.Title($"{x.Item1}");
        plt.XLabel("mem"); plt.YLabel("val");

        var xs = vals.Select(x=>x.idx).ToArray();
        var xl = vals.Select(x=>x.key).ToArray();
        var ys = vals.Select(x=>x.val).ToArray();

        plt.XAxis.ManualTickPositions(xs, xl);
        plt.XAxis.TickLabelStyle(rotation: 90);
        if (ys.Length > 0) plt.PlotBar(xs,ys);
        return plt;
    });
    var pg = new PlotRow(plts.ToArray()).Display();
}

public static IEnumerable<(T,T)> SelectPairs<T>(this IEnumerable<T> input)
{
    return input.SelectMany((x, i) => input.Skip(i + 1), (x, y) => (x, y));
}


var urlsFsAnd = fuzzySets.Where(x=>x.Key.EndsWith("Urls"))
                .SelectPairs()
                .Select(p => ($"{p.Item1.Key}_&_{p.Item2.Key}", FuzzySetOperations.AndOperation<string>(p.Item1.Value,p.Item2.Value, FuzzySetOperations.NormFunctions.Hamacher)));

PlotIntersections(urlsFsAnd);

var domFsAnd = fuzzySets.Where(x=>x.Key.EndsWith("Domains"))
                .SelectPairs()
                .Select(p => ($"{p.Item1.Key}_&_{p.Item2.Key}", FuzzySetOperations.AndOperation<string>(p.Item1.Value,p.Item2.Value, FuzzySetOperations.NormFunctions.Hamacher)));

PlotIntersections(domFsAnd);

var ipsFsAnd = fuzzySets.Where(x=>x.Key.EndsWith("Ips"))
                .SelectPairs()
                .Select(p => ($"{p.Item1.Key}_&_{p.Item2.Key}", FuzzySetOperations.AndOperation<string>(p.Item1.Value,p.Item2.Value, FuzzySetOperations.NormFunctions.Hamacher)));

PlotIntersections(ipsFsAnd);

#!markdown

### Analysis of Distinct Features:

**Fuzzy Set Difference:** Employ fuzzy set operations to determine the differences between sets. This can reveal IoCs that are unique to certain malware families, shedding light on specific behaviors or tactics.

**Unique Characteristics:** Analyze the unique IoCs for their patterns or peculiarities that might be characteristic of a particular malware family or a specific attacker's methodology.

#!csharp

var urlsFsAnd = fuzzySets.Where(x=>x.Key.EndsWith("Urls"))
                .SelectPairs()
                .Select(p => ($"{p.Item1.Key}_&_{p.Item2.Key}", FuzzySetOperations.Difference<string>(p.Item1.Value,p.Item2.Value, FuzzySetOperations.NormFunctions.Hamacher)));

PlotIntersections(urlsFsAnd);

var domFsAnd = fuzzySets.Where(x=>x.Key.EndsWith("Domains"))
                .SelectPairs()
                .Select(p => ($"{p.Item1.Key}_&_{p.Item2.Key}", FuzzySetOperations.Difference<string>(p.Item1.Value,p.Item2.Value, FuzzySetOperations.NormFunctions.Hamacher)));

PlotIntersections(domFsAnd);

var ipsFsAnd = fuzzySets.Where(x=>x.Key.EndsWith("Ips"))
                .SelectPairs()
                .Select(p => ($"{p.Item1.Key}_&_{p.Item2.Key}", FuzzySetOperations.Difference<string>(p.Item1.Value,p.Item2.Value, FuzzySetOperations.NormFunctions.Hamacher)));

PlotIntersections(ipsFsAnd);

#!markdown

## 4. Characterization of Malware Families

4.1 Create IoC Profiles: Develop a profile for each malware family based on the most significant IoCs. This profile would include a set of IoCs that are highly representative of each family.

5.2 Visualization: Use graphical representations, like heatmaps or cluster diagrams, to visually illustrate the relationship and significance of IoCs within and across families.

#!csharp

var profiles = fuzzySets.GroupBy(s => s.Key.Split('.')[0]).ToDictionary(k => k.Key, v => v.ToDictionary(k => k.Key.Split('.')[1], elementSelector: v => v.Value));

profiles.Display();

#!markdown

## 5. Test Malware IoC in Normal Traffic

Considering normal traffic represented by a host context and evaluate IoC profiles in it.

#!csharp

using Ethanol.ContextBuilder.Polishers;
using Ethanol.ContextBuilder.Observable;
using Ethanol.ContextBuilder.Serialization;

var ctxFolder = @"../TestData/ContextBuilder/";
var contexts = File.ReadAllLines(Path.Combine(ctxFolder, "ctx.json")).Select(line => Json.Deserialize<ObservableEvent<IpTargetHostContext>>(line));

record ContextIoas(DateTime Start, DateTime End, string Host, string[] Urls, string[] Domains, string[] Ips);

// convert to fuzzy sets:
ContextIoas GetContextIoas(ObservableEvent<IpTargetHostContext> context)
{
    return new ContextIoas(context.StartTime, context.EndTime, context.Payload.HostAddress.ToString(), 
    context.Payload.WebUrls.Select(x=>x.Url).ToArray(), 
    context.Payload.ResolvedDomains.Select(d=>d.ResponseData).ToArray(), 
    context.Payload.Connections.Select(c=>c.RemoteHostAddress).ToArray());
}

var contextIocs = contexts.Select(c => GetContextIoas(c));

contextIocs.Display();
