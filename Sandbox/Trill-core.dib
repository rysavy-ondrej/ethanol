#!csharp

#r "System.Reactive"
#r "nuget:Trill"
#r "..\bin\Debug\net5.0\Ethanol.Streaming.dll"

using System.Reactive;
using System.Reactive.Linq;
using Microsoft.StreamProcessing;
using Ethanol.Streaming;

void PrintStream<V>(IStreamable<Empty,V> stream, Func<StreamEvent<V>, bool> predicate)
{
    stream.ToStreamEventObservable().Where(predicate).ForEachAsync(e=>Console.WriteLine($"[{e.StartTime},{e.EndTime}):{e.Payload}")).Wait();
}
void PrintStreams<V>(IStreamable<Empty,V>[] streams, Func<StreamEvent<V>, bool> predicate)
{
    var observables = streams.Select(s=> s.ToStreamEventObservable().Where(predicate)).ToArray();
    var tasks = observables.Select(o=> o.ForEachAsync(e=>Console.WriteLine($"[{e.StartTime},{e.EndTime}):{e.Payload}")));
    Task.WaitAll(tasks.ToArray());
}

#!csharp

// Records enjoy structural equality!
record B(int x);
record A(string S, object I);
var x = new A("123", new B(1));
var y = new A("123", new B(1));
var b = x == y;
b.Display()

#!csharp

record Artifact (string Id, long Start, long Duration, string value);

var events = new Artifact[]
{
    new Artifact("A",10,5, "TCP"),
    new Artifact("B",12,5, "UDP"),
    new Artifact("C",14,5, "TCP"),
    new Artifact("D",16,5, "UDP"),
    new Artifact("E",18,5, "TCP"),
    new Artifact("F",20,5, "UDP"),

}.Select(x => StreamEvent.CreatePoint(x.Start, x)).ToObservable();
var stream = events.ToStreamable().QuantizeLifetime(15,5);
var array = await stream.ToStreamEventObservable().ToArray();
array.Display();

#!markdown

# Join

LeftOuterJoin is an operation that takes all left events and tries to find corresponding right events. If there is not any right event then the left event is in the output with the right value provided by the function.

Example bellow pairs artifacts based on their values. As can be seen only those events that overlaps can be paired.

#!csharp

var joinStream = stream.LeftOuterJoin(stream, left => left.value, right => right.value, left => new { Left = left, Right = new Artifact(null, 0,0,null)},(left,right) =>  new { Left = left, Right = right});
var array = await joinStream.ToStreamEventObservable().ToArray();
array.Display()

#!markdown

# GroupApply

Grouping is combined in apply operation, which means that stream is first partitioned into groups and to each group specified operation is applied.

#!csharp

var groupStream = joinStream.GroupApply(x=>x.Left, g => g.Aggregate(d => d.CollectSet(x=>x.Right)), (k,v) => new { Key = k.Key, Value = v });
var array = await groupStream.ToStreamEventObservable().Where(e=>e.IsEnd).ToArray();
array.Display()

#!markdown

# Multicast

Multicast is used to inspect the stream in several places without the necessity to contruct it multiple times.

#!markdown

The GroupApply operation has the following signature:

```
IStreamable<Empty, TResult> GroupApply<TSource,TKey,TValue,TResult>(
    this IStreamable<Empty, TSource> stream, 
    Func<TSource,TKey> keySelector, 
    Func<TSource,TValue> applyFunc, 
    Func<TKey,TValue,TResult> resultSelector)
```
where `keySelector` gives a key to be used in group operation, `applyFunc` is applied on the input data in each group to produce an intermediate value (possibly aggregated), and `resultSelector` is given key and value to produce the result.
