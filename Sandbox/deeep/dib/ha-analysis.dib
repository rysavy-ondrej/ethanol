#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!csharp

#r "nuget:Microsoft.ML"
#r "nuget:Microsoft.ML.TimeSeries"
using System.Text.Json;
using System.IO;
using Microsoft.ML;
using Microsoft.ML.Data;
using Microsoft.ML.Transforms.TimeSeries;


#r "nuget:ScottPlot"
// Setup a custom formatter to display plots as images
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHTML()), HtmlFormatter.MimeType);

var mlContext = new MLContext();

#!csharp

public record HaDataPoint
{
    public string name { get; set; }
    public string message { get; set; }
    public DateTime when { get; set; }
    public string domain { get; set; }
    public string state { get; set; }
    public string entity_id { get; set; }
}
var jsonStream  = new FileStream("../data/ha_data.json", FileMode.Open);
var records = JsonSerializer.Deserialize<List<HaDataPoint>>(jsonStream);
Console.WriteLine($"Total records = {records.Count}");

#!markdown

# Anomaly Estimator using SRCNN

Create SrCnnAnomalyEstimator, which detects timeseries anomalies using SRCNN algorithm.

#!markdown

STEP 1: Prepare time-series data into a IDataView object.

#!csharp

public record InputPoint
{
    public string SensorName { get; set; }
    public DateTime Date { get; set; }
    public float Value { get; set; }
}

public class OutputPoint
{
    public string SensorName { get; set; }
    public DateTime Date { get; set; }
    public float Value { get; set; }

    [VectorType(3)]
    public double[] Prediction { get; set; }
}

IEnumerable<InputPoint> GetInputPointForSensor(IEnumerable<HaDataPoint> rawSensorValues, string sensorName)
{
    var sensorValues = rawSensorValues.Where(x=>String.Equals(x.entity_id,sensorName));
    var inputPoints = sensorValues.Select(y=> new InputPoint { SensorName = y.entity_id, Date = y.when, Value = y.state == "on" ? 1 : 0 });
    var dataPoints = inputPoints
        .GroupBy(ip => new DateTime(ip.Date.Year, ip.Date.Month, ip.Date.Day, ip.Date.Hour, 0, 0))
        .Select(g => new InputPoint
        {
            SensorName = g.First().SensorName,
            Date = g.Key,
            Value = g.Sum(ip => ip.Value)
        }).ToList();
    return dataPoints;
}

var hallmotion1 = GetInputPointForSensor(records,"binary_sensor.hall_motion_1");
var hallmotion2 = GetInputPointForSensor(records,"binary_sensor.hall_motion_2");

// need to transform from entities to input points.
var dataview1 = mlContext.Data.LoadFromEnumerable(hallmotion1);
var dataview2 = mlContext.Data.LoadFromEnumerable(hallmotion2);

var dataX = Enumerable.Range(1, aggregatedPoints.Count).Select(x=>(double)x).ToArray();
var dataY = aggregatedPoints.Select(x=>(double)x.Value).ToArray();
var plt = new ScottPlot.Plot(400, 300);
plt.AddScatter(dataX, dataY);

// display the plot
plt

#!markdown

STEP 2: Create a new instance of the detector class and specify the input and output columns of your data, as well as the paameters of the SRCNN algorithmus.

#!csharp

ITransformer model = mlContext.Transforms.DetectAnomalyBySrCnn(
                outputColumnName: "Prediction", 
                inputColumnName: "Value", 
                windowSize: 16, 
                backAddWindowSize: 5, 
                lookaheadWindowSize: 5, 
                averagingWindowSize: 3, 
                judgementWindowSize: 8, 
                threshold: 0.35).Fit(
                dataview);

#!markdown

STEP 3: Create the detection engine.

#!csharp

 var engine = model.CreateTimeSeriesEngine<InputPoint,
                OutputPoint>(mlContext);

#!markdown

STEP 4: Use the forecaster to predict future values by creating a new IDataView object with the future dates you want to predict.

#!csharp

foreach(var input in .OrderByDescending(x=>x.Value))
{
    var output = engine.Predict(input);
    output.Display();
}
