#!markdown

# Detection of VPN/TOR

This playbook is about context-based detection of TOR/VPN traffic.


## TOR connections
For some information on Tor: https://ipdata.co/blog/tor-detection/

The idea of detection TOR traffic is to identify connection that uses TOR exit point node(s) for communication. Although there is a list of exit nodes that can be used to identify the TOR exit nodes, it is also possible to detect the communication by performing correlation on flows. TOR client establishes multiple connections to the exit nodes. 
The detector should be able to identify TOR session and provide the following information:

* Client identity
* TOR exit nodes
* list of related flows
* amount of upload bytes/packets
* amount of download bytes/packets
* duration


To detect TOR flows, we can apply the following rules based on the multiple observations:

* TOR connection to the exit node is encrypted using TLS, it seems that all connections done by a single TOR client have the same client's ciphersuite list (even JA3 fingerprint). 
* TOR TLS server name (SNI) is commonly a generated domain name, e.g., `www.ivuq24fj4fwmink.com`. This string is not constant and changes with every connection.
* TOR exit nodes may listen on a variety of ports, it seems that default is 9001, but any port can be used.
* Some TOR nodes have a reverse DNS record, e.g., `torexit.as3265.net`.

The initial step may be the identification of communication with a directory server during the bootstrap procedure:

Tor ships with a list of directory authorities and some information about them. In particular, this information includes for each authority its IP address, onion port and onion key fingerprint.
This makes it possible for clients to make an onion connection to one or more authorities for bootstrapping purposes. It then connects to the authority's DirPort via the onion connection to that authority.

#!markdown

This notebook uses dataset with TOR communication originated only from the single node (192.168.111.18). Note that this node also have other (encrypted) communication.   

#!csharp

#r "nuget:System.Reactive"
#r "nuget:Trill"
#r "nuget:YamlDotNet"
#r "..\bin\Debug\net5.0\Ethanol.Core.dll"
#r "..\bin\Debug\net5.0\Ethanol.Streaming.dll"
#r "..\bin\Debug\net5.0\Ethanol.Console.dll"

using System.IO;
using System.Reactive;
using System.Reactive.Linq;
using Microsoft.StreamProcessing;
using System.Reflection;
using System.CodeDom.Compiler;

using Ethanol.Console;
using Ethanol.Streaming;
using Ethanol.Artifacts;
using Ethanol.Providers;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

void PrintStream<V>(IStreamable<Empty,V> stream, Func<StreamEvent<V>, bool> predicate, int count = Int32.MaxValue)
{
    stream.ToStreamEventObservable().Where(predicate).Take(count).ForEachAsync(e=>Console.WriteLine($"[{e.StartTime},{e.EndTime}):{e.Payload}")).Wait();
}

IList<StreamEvent<V>> GetList<V>(IStreamable<Empty,V> stream, Func<StreamEvent<V>, bool> predicate)
{
    return stream.ToStreamEventObservable().Where(predicate).ToList().FirstAsync().Wait();    
}

#!markdown

# Functions used in the analysis

In the analysis, some functions are used to compute various values:

* Entropy gives as the randomness of the string computed as $H = - \sum p(x) log(p(x))$
 

#!csharp

public double ComputeEntropy(string message)
{
    Dictionary<char, int> K = message.GroupBy(c => c).ToDictionary(g => g.Key, g => g.Count());
    double entropyValue = 0;
    foreach (var character in K)
    {
        double PR = character.Value / (double) message.Length;
        entropyValue -= PR * Math.Log(PR, 2);
    }
    return entropyValue;
}
public double ComputeDnsEntropy(string domain)
{
    var parts = domain.Split('.');
    return parts.Select(ComputeEntropy).Max();
}
var yamlSerializer = new SerializerBuilder().WithNamingConvention(CamelCaseNamingConvention.Instance).DisableAliases().Build();
public void PrintStreamEvent<T>(string eventType, StreamEvent<T> obj)
{
    if (obj.IsInterval || obj.IsEnd)
    {
        var evt = new { Event = eventType, ValidTime = new { Start = new DateTime(obj.StartTime), End = new DateTime(obj.EndTime) }, Payload = obj.Payload };
        Console.WriteLine(yamlSerializer.Serialize(evt));
    }
}

#!csharp

ComputeDnsEntropy("imap.gmail.com").Display();
ComputeDnsEntropy("www.6b6fpspfv2ngcv654f5r.com").Display();

#!markdown

# Prepare input data

#!csharp

using System.Reactive.Linq;
using System.Reactive.Subjects;

var windowSize = TimeSpan.FromMinutes(15);
var windowHop = TimeSpan.FromMinutes(5);
var files = Directory.GetFiles(@"D:\Applications\Ethanol\Data").ToObservable();
var subject = new Subject<RawIpfixRecord>();
var loader = new CsvLoader<RawIpfixRecord>();
loader.OnReadRecord += (object _, RawIpfixRecord value) => { subject.OnNext(value); };

// input stream:
var flowStream = subject.GetWindowedEventStream(x=> DateTime.Parse(x.TimeStart).Ticks, windowSize, windowHop).Multicast(2);

// producer:
var producerTask = files.ForEachAsync(f => loader.Load(f, File.OpenRead(f)).Wait())
           .ContinueWith(_ => subject.OnCompleted());
                      

var sshScanStream = flowStream[0]
    .Where(f => f.Protocol == "TCP" && f.InPackets <= 2)
    .GroupApply(f => new { f.SrcIp }, 
                group => group.Aggregate(aggregate => aggregate.Collect(flow => new Flow(flow.Protocol, flow.SrcIp, flow.SrcPort, flow.DstIp, flow.DstPort))),
                (key,value) => new { Key = key.Key, Value = value.Distinct().ToArray() })
    .Where(g => g.Value.Count() > 2);

var sshBruteForceStream = flowStream[1]
    .Where(f => f.Protocol == "TCP" && f.InPackets >= 8 && f.InPackets <= 14)
    .GroupApply(f => new { f.SrcIp }, 
        group => group.Aggregate(aggregate => aggregate.Collect(flow =>  new Flow(flow.Protocol, flow.SrcIp, flow.SrcPort, flow.DstIp, flow.DstPort))),
        (key,value) => new { Key = key.Key, Value = value.Distinct().ToArray() })
    .Where(g => g.Value.Count() > 5);

var sshScanTask = sshScanStream.ToStreamEventObservable().ForEachAsync(x=>PrintStreamEvent("ssh-scan", x));
var sshBruteForceTask = sshBruteForceStream.ToStreamEventObservable().ForEachAsync(x=>PrintStreamEvent("ssh-brute", x));

await Task.WhenAll(producerTask, sshScanTask, sshBruteForceTask);
loader.FlowCount.Display();
