using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Ethanol.ContextBuilder.Context;
using Ethanol.ContextBuilder.Plugins.Attributes;
using Ethanol.ContextBuilder.Readers.DataObjects;
using Ethanol.ContextBuilder.Serialization;
using Microsoft.Extensions.Logging;
using YamlDotNet.Serialization;

namespace Ethanol.ContextBuilder.Readers
{
    /// <summary>
    /// Provides a reader to process flow data from the flowmonexp5 tool's JSON output. Note that in this specific export format,
    /// each flow is depicted as an individual JSON object, distinct from standard NDJSON or a conventional JSON object array.
    /// </summary>
    /// <remarks>
    /// The class supports two primary modes of operation:
    /// <list type="number">
    /// <item>Reading data from a file through the derived <see cref="FileReader"/> class.</item>
    /// <item>Continuously fetching data from an open TCP socket using the derived <see cref="TcpReader"/> class.</item>
    /// </list>
    /// The choice between these modes is dictated by the provided configuration supplied to <see cref="Create(Flowmonexp5JsonReader.Configuration)"/> method.
    /// </remarks>
    [Plugin(PluginCategory.Reader, "FlowmonJson", "Processes JSON exports with IPFIX data generated by the flowmonexp5 tool.")]
    abstract class Flowmonexp5JsonReader : BaseFlowReader<IpFlow>

    {
        /// <summary>
        /// Logger instance for the class to record events and issues.
        /// </summary>
        static protected ILogger __logger = LogManager.GetCurrentClassLogger();

        /// <summary>
        /// Options used for JSON serialization processes.
        /// </summary>
        protected readonly JsonSerializerOptions _serializerOptions;

        /// <summary>
        /// Configuration for the FlowexpJsonReader.
        /// </summary>
        public class Configuration
        {
            /// <summary>
            /// Gets or sets the name of the file with JSON data to be read. Defaults to standard input if not provided.
            /// </summary>
            [YamlMember(Alias = "file", Description = "The file name with JSON data to read. If not provided then STDIN will be used.")]
            public string FileName { get; set; }

            /// <summary>
            /// Gets or sets the host and port information for binding a TCP server. Use 0.0.0.0 to bind to all interfaces.
            /// </summary>
            [PluginParameter(Name: "tcp", PluginParameterFlag.Optional, Description: "The host:port information for binding the tcp server. Use 0.0.0.0 to bind on all interfaces.")]
            [YamlMember(Alias = "tcp")]
            public string TcpConnection { get; set; }
        }

        /// <summary>
        /// Factory method to create a new instance of FlowexpJsonReader based on the given configuration.
        /// </summary>
        /// <param name="configuration">The configuration details used to initialize the reader.</param>
        /// <returns>A new instance of the <see cref="Flowmonexp5JsonReader"/> class.</returns>
        [PluginCreate]
        public static Flowmonexp5JsonReader Create(Configuration configuration)
        {
            var tcpReader = configuration.TcpConnection != null ? TcpReader.CreateFromConnectionString(configuration.TcpConnection) : null;
            if (tcpReader != null) return tcpReader;
            else
            {
                var reader = configuration.FileName != null ? File.OpenText(configuration.FileName) : System.Console.In;
                return new FileReader(reader);
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Flowmonexp5JsonReader"/> class.
        /// </summary>
        Flowmonexp5JsonReader()
        {
            _serializerOptions = new JsonSerializerOptions();
            _serializerOptions.Converters.Add(new DateTimeJsonConverter());
        }

        /// <summary>
        /// Attempts to deserialize the given input string into a FlowexpEntry instance.
        /// </summary>
        /// <param name="input">The JSON input string to deserialize.</param>
        /// <param name="entry">The resulting <see cref="Flowmonexp5Entry"/> object if the deserialization is successful.</param>
        /// <returns>True if deserialization is successful, otherwise false.</returns>
        bool TryDeserialize(string input, out Flowmonexp5Entry entry)
        {
            try
            {
                entry = JsonSerializer.Deserialize<Flowmonexp5Entry>(input, _serializerOptions);
                return true;
            }
            catch (Exception e)
            {
                __logger.LogWarning($"Cannot deserialize entry: {e.Message}");
                entry = default;
                return false;
            }
        }

        /// <summary>
        /// Reads a JSON string from the input stream. This method supports reading both NDJSON (Newline Delimited JSON) 
        /// where each line is a complete JSON object, and multi-line formatted JSON until it reaches the end of an object.
        /// </summary>
        /// <param name="inputStream">The TextReader stream to read the JSON string from.</param>
        /// <returns>A string representation of the JSON object, or null if the end of the file is reached or the content is whitespace.</returns>
        public static string ReadJsonString(TextReader inputStream)
        {
            var buffer = new StringBuilder();

            while (true)
            {
                var line = inputStream.ReadLine()?.Trim();

                // End of file?
                if (line == null) break;

                buffer.AppendLine(line);

                // Check for the end of JSON object (either NDJSON or multiline JSON)
                if ((line.StartsWith("{") && line.EndsWith("}")) || line == "}") break;
            }
            var record = buffer.ToString().Trim();
            return string.IsNullOrWhiteSpace(record) ? null : record;
        }

        class FileReader : Flowmonexp5JsonReader
        {
            private readonly TextReader _reader;

            /// <summary>
            /// Initializes the reader with underlying <see cref="TextReader"/>.
            /// </summary>
            /// <param name="reader">The text reader device (input file or standard input).</param>
            public FileReader(TextReader reader)
            {
                _reader = reader;

            }

            /// <inheritdoc/>
            protected override void Open()
            {
                // nothing to do, reader is always provided as open...
            }

            /// <inheritdoc/>
            protected override bool TryGetNextRecord(CancellationToken ct, out IpFlow ipFlow)
            {
                ipFlow = null;
                var line = ReadJsonString(_reader);
                if (line == null) return false;
                if (TryDeserialize(line, out var currentEntry))
                {
                    ipFlow = currentEntry.ToFlow();
                    return true;
                }
                return false;
            }
            /// <inheritdoc/>
            protected override void Close()
            {
                _reader.Close();
            }

            public override string ToString()
            {
                return $"{nameof(Flowmonexp5JsonReader)}(Reader={_reader})";
            }
        }
        class TcpReader : Flowmonexp5JsonReader
        {
            IPEndPoint _endpoint;
            private TcpListener _listener;
            private Task _mainLoopTask;
            private List<Task> _clientsTasks;
            private CancellationTokenSource _cancellationTokenSource;
            private BlockingCollection<IpFlow> _queue;

            public TcpReader(IPEndPoint endPoint)
            {
                _endpoint = endPoint;
                _cancellationTokenSource = new CancellationTokenSource();
                _queue = new BlockingCollection<IpFlow>();
                _clientsTasks = new List<Task>();
            }

            public async Task RunAsync(TcpListener listener, CancellationToken cancellation)
            {
                __logger.LogInformation($"TCP server listening on {_endpoint}");
                try
                {
                    // Wait for incoming client connections
                    while (!cancellation.IsCancellationRequested)
                    {
                        var client = await listener.AcceptTcpClientAsync(cancellation);
                        __logger.LogInformation($"TCP server accepts connection from {client?.Client.RemoteEndPoint}");
                        if (client != null)
                        {
                            var tcs = new TaskCompletionSource<object>();
                            _clientsTasks.Add(tcs.Task);
                            // Start as a background task... 
                            var _ = Task.Factory.StartNew(() =>
                            {
                                ReadInputData(client, cancellation);
                                _clientsTasks.Remove(tcs.Task);
                                tcs.SetResult(null);
                            },  cancellation);
                        }
                    }
                }
                catch (SocketException ex)
                {
                    __logger.LogError($"Socket exception: {ex.Message}");
                }
                finally
                {
                    // Stop listening for client connections when done
                    listener.Stop();
                    
                }
            }
            private void ReadInputData(TcpClient client, CancellationToken cancellation)
            {
                // get the stream
                var stream = client.GetStream();
                // gets the reader from stream:
                var reader = new StreamReader(stream);
                string jsonString;
                while(!cancellation.IsCancellationRequested &&  (jsonString = ReadJsonString(reader)) != null)
                {
                    // read input tcp data and if suceffuly deserialized put the object in the buffer
                    // to be available to TryGetNextRecord method.
                    if (this.TryDeserialize(jsonString, out var currentEntry))
                    {
                        var ipflow = currentEntry.ToFlow();
                        _queue.Add(ipflow);
                    }
                    else
                    {
                        __logger.LogError($"Invalid input data: Cannot deserialize input {jsonString.Substring(0,64)}.");
                    }
                }
                reader.Close();
                client.Close();
               
            }

            protected override void Open()
            {
                _listener = new TcpListener(_endpoint);
                _listener.Start();  
                _mainLoopTask = RunAsync(_listener, _cancellationTokenSource.Token);
            }

            protected override bool TryGetNextRecord(CancellationToken cancellation, out IpFlow record)
            {
                // Take does not wait in the case the input is completed.
                // In this case the return valus is null.
                record = _queue.Take(cancellation);
                return record != null;
            }

            protected override void Close()
            {
                _queue.CompleteAdding();
                var activeTasks = _clientsTasks.Append(_mainLoopTask).ToArray();
                _cancellationTokenSource.Cancel();
                Task.WhenAll(activeTasks);
            }

            /// <summary>
            /// Creates a new TcpReader instance by parsing the provided connection string into an IPEndPoint.
            /// </summary>
            /// <param name="connectionString">The connection string in the format "host:port" to be used for establishing the TCP connection.</param>
            /// <returns>A new <see cref="TcpReader"/> instance for the given connection string, or null if an error occurs during creation.</returns>
            internal static TcpReader CreateFromConnectionString(string connectionString)
            {
                try
                {
                    // Parse the connection string into an IPEndPoint object
                    var endpoint = IPEndPointResolver.GetIPEndPoint(connectionString);
                    __logger.LogInformation($"Listening for incoming tcp connection, endpoint={endpoint}.");
                    // Create the writer
                    return new TcpReader(endpoint);
                }
                catch (Exception ex)
                {
                    __logger.LogError($"Error creating TcpReader from '{connectionString}' string: {ex.Message}");
                    return null;
                }
            }
        }
    }
}
