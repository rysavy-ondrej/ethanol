#!markdown

# Detection of VPN/TOR

This playbook is about context-based detection of TOR/VPN traffic.


## TOR connections
For some information on Tor: https://ipdata.co/blog/tor-detection/

The idea of detection TOR traffic is to identify connection that uses TOR exit point node(s) for communication. Although there is a list of exit nodes that can be used to identify the TOR exit nodes, it is also possible to detect the communication by performing correlation on flows. TOR client establishes multiple connections to the exit nodes. 
The detector should be able to identify TOR session and provide the following information:

* Client identity
* TOR exit nodes
* list of related flows
* amount of upload bytes/packets
* amount of download bytes/packets
* duration


To detect TOR flows, we can apply the following rules based on the multiple observations:

* TOR connection to the exit node is encrypted using TLS, it seems that all connections done by a single TOR client have the same client's ciphersuite list (even JA3 fingerprint). 
* TOR TLS server name (SNI) is commonly a generated domain name, e.g., `www.ivuq24fj4fwmink.com`. This string is not constant and changes with every connection.
* TOR exit nodes may listen on a variety of ports, it seems that default is 9001, but any port can be used.
* Some TOR nodes have a reverse DNS record, e.g., `torexit.as3265.net`.

The initial step may be the identification of communication with a directory server during the bootstrap procedure:

Tor ships with a list of directory authorities and some information about them. In particular, this information includes for each authority its IP address, onion port and onion key fingerprint.
This makes it possible for clients to make an onion connection to one or more authorities for bootstrapping purposes. It then connects to the authority's DirPort via the onion connection to that authority.

#!markdown

This notebook uses dataset with TOR communication originated only from the single node (192.168.111.18). Note that this node also have other (encrypted) communication.   

#!csharp

#r "nuget:System.Reactive"
#r "nuget:Trill"

#r "..\bin\Debug\net5.0\Ethanol.Core.dll"
#r "..\bin\Debug\net5.0\Ethanol.Streaming.dll"
#r "..\bin\Debug\net5.0\Ethanol.Demo.dll"

using System.Reactive;
using System.Reactive.Linq;
using Microsoft.StreamProcessing;
using System.Reflection;
using System.CodeDom.Compiler;

using Ethanol.Demo;
using Ethanol.Streaming;
using Ethanol.Artifacts;
using Ethanol.Context;
using Ethanol.Providers;


void PrintStream<V>(IStreamable<Empty,V> stream, Func<StreamEvent<V>, bool> predicate, int count = Int32.MaxValue)
{
    stream.ToStreamEventObservable().Where(predicate).Take(count).ForEachAsync(e=>Console.WriteLine($"[{e.StartTime},{e.EndTime}):{e.Payload}")).Wait();
}

IList<StreamEvent<V>> GetList<V>(IStreamable<Empty,V> stream, Func<StreamEvent<V>, bool> predicate)
{
    return stream.ToStreamEventObservable().Where(predicate).ToList().FirstAsync().Wait();    
}

#!markdown

# Functions used in the analysis

In the analysis, some functions are used to compute various values:

* Entropy gives as the randomness of the string computed as $H = - \sum p(x) log(p(x))$
 

#!csharp

public double ComputeEntropy(string message)
{
    Dictionary<char, int> K = message.GroupBy(c => c).ToDictionary(g => g.Key, g => g.Count());
    double entropyValue = 0;
    foreach (var character in K)
    {
        double PR = character.Value / (double) message.Length;
        entropyValue -= PR * Math.Log(PR, 2);
    }
    return entropyValue;
}
public double ComputeDnsEntropy(string domain)
{
    var parts = domain.Split('.');
    return parts.Select(ComputeEntropy).Max();
}

#!csharp

ComputeDnsEntropy("imap.gmail.com").Display();
ComputeDnsEntropy("www.6b6fpspfv2ngcv654f5r.com").Display();

#!markdown

# Prepare input data

#!csharp

var artifactServiceCollection = new ArtifactServiceCollection(Assembly.GetAssembly(typeof(ArtifactHttp)));
artifactServiceCollection.AddArtifactFromCsvFiles(@"..\Data");
var artifactServices = artifactServiceCollection.Build();
artifactServices.Services.Select(r => { var s = artifactServices.GetService(r); return $"{s.ArtifactType} [{s.Source}]"; }).Display();

var windowSize = TimeSpan.FromMinutes(15);
var windowHop = TimeSpan.FromMinutes(5);
var flowStream = artifactServices.GetService(artifactServiceCollection.GetArtifactTypeByName("flow")).GetStreamable<IpfixArtifact>().HoppingWindowLifetime(windowSize.Ticks, windowHop.Ticks);                        
var dnsStream =  artifactServices.GetService(artifactServiceCollection.GetArtifactTypeByName("dns")).GetStreamable<ArtifactDns>().HoppingWindowLifetime(windowSize.Ticks, windowHop.Ticks);
var httpStream = artifactServices.GetService(artifactServiceCollection.GetArtifactTypeByName("http")).GetStreamable<ArtifactHttp>().HoppingWindowLifetime(windowSize.Ticks, windowHop.Ticks);
var tlsStream = artifactServices.GetService(artifactServiceCollection.GetArtifactTypeByName("tls")).GetStreamable<ArtifactTls>().HoppingWindowLifetime(windowSize.Ticks, windowHop.Ticks);

display($"Flow count = {GetList(flowStream, e=>e.IsData).Count}");
display($"Dns count = {GetList(dnsStream, e=>e.IsData).Count}");
display($"Http count = {GetList(httpStream, e=>e.IsData).Count}");
display($"Tls count = {GetList(tlsStream, e=>e.IsData).Count}");

#!markdown

# Process input flows

#!markdown

## Pair TLS and DNS records 

For TLS records, the cadidate DNS records are identified. The rationale behind this reasoning is that most the TLS connections starts by querying domain name of the destination endpoint. However this is not always the case. For instance, some queries may be locally cached, or the application connects directly to IP address as their use their own resolution mechanism or directory, e.g., TOR and some system services.   

#!csharp

var tlsDomain = tlsStream.Where(f=>f.SourcePort > f.DestinationPort).LeftOuterJoin(
    dnsStream.AlterEventDuration(t => t + TimeSpan.FromMinutes(30).Ticks),  
    f => new { HOST = f.SrcIp, DA = f.DstIp },
    f => new { HOST = f.DstIp, DA = f.DnsResponseData }, 
    l => new { TlsFlow = l, ServerName = l.TlsServerName, CommonName = l.TlsSubjectCommonName, DomainName = string.Empty, Entropy = ComputeEntropy(l.TlsServerName) }, 
    (l,r) => new { TlsFlow = l, ServerName = l.TlsServerName, CommonName = l.TlsSubjectCommonName, DomainName = r.DnsQuestionName, Entropy = ComputeEntropy(l.TlsServerName)}); 

#!markdown

## Primary TOR connections

Using a simple (heuristic) rules we try to identify the TOR related TLS handshakes:

* Generated server name, which means that Entropy is rather high (TODO: here we can also use ngrams for improving precision) as some regular names can also have quite high entropy
* TLS Common name is missing, which is not the case for all TOR connections but a significat amount of exit nodes just does not provide this information.
* Empty domain name, as there is not DNS resolution associated with this connection

#!csharp

var torHandshakes = tlsDomain.Where(e=> String.IsNullOrWhiteSpace(e.DomainName) && e.CommonName == "N/A" && e.Entropy > 3);
var exitNodes = torHandshakes.Select(f => new { DA = f.TlsFlow.DstIp, DP = f.TlsFlow.DstPt, ServerName = f.ServerName, JA3 = f.TlsFlow.Ja3Fingerprint } );
GetList(exitNodes, e=>e.IsData).Display();

#!markdown

## Identify other TOR exit nodes

As a Tor client still uses the same cipher suites in the handshake with all end points, it is possible to identify other exit nodes. 
 

#!csharp

var allExitNodes  = exitNodes.Join(tlsStream.Where(f=>f.SourcePort > f.DestinationPort),
    l => l.JA3,
    r => r.Ja3Fingerprint,
    (l,r) => new { DA = r.DstIp, DP = r.DstPt, JA3 = l.JA3 }
).Distinct();
GetList(allExitNodes, e=>e.IsEnd).Display()

#!markdown

## Identify the individual flows as TOR

As we have identified TOR exit nodes, we can match the corresponding TCP flows.

#!csharp

record Tor(string Client, string ExitNode);

var contextFlowStream = flowStream.LeftOuterJoin(allExitNodes,
        l => new { DA = l.DstIp, DP = l.DstPt },
        r => new { DA = r.DA, DP = r.DP },       
        l => new { Flow = l,  Tor = (Tor)null  },
        (l,r) => new { Flow = l,  Tor  = new Tor(l.SrcIp, l.DstIp) } 
    );

   
GetList(contextFlowStream.Where(f => f.Flow.SrcIp =="192.168.111.18" && f.Flow.DstIp == "188.114.140.233" ), e=>e.IsEnd || e.IsInterval).Display();  
    

#!markdown

# Notes on time 

The simplified approach was taken to handle the temporal information. Lifetime of each flow does not corresponds to the exact duration of the flow but it is aligned by hopping window.  This enables to correlate flows in that appears in the hopping window without the necessaity to adjust lifetime of individual flows. Still, it is possible to test if two flows are simultaneous by comparing their time information fields. 

#!markdown

# TOR Analyzer Output

The TOR analyzer outputs on every closing of the hopping window the following:

* list of active TOR clients
* list of used TOR exit nodes
* aggregated data on TOR traffic, up/down for clients, exist nodes, etc.

#!csharp

var torClientsStream = contextFlowStream.Where(f=>f.Tor != null).GroupAggregate(f => f.Tor.Client, 
    g => g.Count(), 
    g => g.Sum(f=>Int32.Parse(f.Flow.Packets)), 
    g => g.Sum(f=>Int32.Parse(f.Flow.Bytes)),
    g => g.Collect(f => f.Tor.ExitNode), 
    g => g.Collect(f => f.Flow.Id),
    (k,g1,g2,g3,g4,g5) => new {TorClient = k.Key, Flows = g1, Packets = g2, Bytes = g3, ExitNodes = g4.Distinct().OrderBy(x=>x).ToArray(), FlowRefs =  g5.Distinct().OrderBy(x=>x).ToArray() });

"TOR CLIENTS".Display();
GetList(torClientsStream, e=>e.IsEnd || e.IsInterval).Display(); 

var torExitsStream = contextFlowStream.Where(f=>f.Tor != null).GroupAggregate(f => f.Tor.ExitNode, 
    g => g.Count(), 
    g => g.Sum(f=>Int32.Parse(f.Flow.Packets)), 
    g => g.Sum(f=>Int32.Parse(f.Flow.Bytes)), 
    g => g.Collect(f => f.Tor.Client), 
    g => g.Collect(f => f.Flow.Id),
    (k,g1,g2,g3,g4,g5) => new {TorExit = k.Key, Flows = g1, Packets = g2, Bytes = g3, Clients = g4.Distinct().OrderBy(x=>x).ToArray(), FlowRefs =  g5.Distinct().OrderBy(x=>x).ToArray() });

"TOR EXITS".Display();
GetList(torExitsStream, e=>e.IsEnd || e.IsInterval).Display(); 
