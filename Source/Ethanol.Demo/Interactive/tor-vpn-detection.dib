#!markdown

# Detection of VPN/TOR

This playbook is about context-based detection of TOR/VPN traffic.


## TOR connections
For some information on Tor: https://ipdata.co/blog/tor-detection/

The idea of detection TOR traffic is to identify connection that uses TOR exit point node(s) for communication. Although there is a list of exit nodes that can be used to identify the TOR exit nodes, it is also possible to detect the communication by performing correlation on flows. TOR client establishes multiple connections to the exit nodes. 
The detector should be able to identify TOR session and provide the following information:

* Client identity
* TOR exit nodes
* list of related flows
* amount of upload bytes/packets
* amount of download bytes/packets
* duration


To detect TOR flows, we can apply the following rules based on the multiple observations:

* TOR connection to the exit node is encrypted using TLS, it seems that all connections done by a single TOR client have the same client's ciphersuite list (even JA3 fingerprint). 
* TOR TLS server name (SNI) is commonly a generated domain name, e.g., `www.ivuq24fj4fwmink.com`. This string is not constant and changes with every connection.
* TOR exit nodes may listen on a variety of ports, it seems that default is 9001, but any port can be used.
* Some TOR nodes have a reverse DNS record, e.g., `torexit.as3265.net`.

The initial step may be the identification of communication with a directory server during the bootstrap procedure:

Tor ships with a list of directory authorities and some information about them. In particular, this information includes for each authority its IP address, onion port and onion key fingerprint.
This makes it possible for clients to make an onion connection to one or more authorities for bootstrapping purposes. It then connects to the authority's DirPort via the onion connection to that authority.

#!markdown

This notebook uses dataset with TOR communication originated only from the single node (192.168.111.18). Note that this node also have other (encrypted) communication.   

#!csharp

#r "nuget:System.Reactive"
#r "nuget:Trill"

#r "..\bin\Debug\net5.0\Ethanol.Core.dll"
#r "..\bin\Debug\net5.0\Ethanol.Streaming.dll"
#r "..\bin\Debug\net5.0\Ethanol.Demo.dll"

using System.Reactive;
using System.Reactive.Linq;
using Microsoft.StreamProcessing;
using System.Reflection;
using System.CodeDom.Compiler;

using Ethanol.Demo;
using Ethanol.Streaming;
using Ethanol.Artifacts;
using Ethanol.Context;
using Ethanol.Providers;


void PrintStream<V>(IStreamable<Empty,V> stream, Func<StreamEvent<V>, bool> predicate, int count = Int32.MaxValue)
{
    stream.ToStreamEventObservable().Where(predicate).Take(count).ForEachAsync(e=>Console.WriteLine($"[{e.StartTime},{e.EndTime}):{e.Payload}")).Wait();
}

IList<StreamEvent<V>> GetList<V>(IStreamable<Empty,V> stream, Func<StreamEvent<V>, bool> predicate)
{
    return stream.ToStreamEventObservable().Where(predicate).ToList().FirstAsync().Wait();    
}

#!markdown

# Functions used in the analysis

In the analysis, some functions are used to compute various values:

* Entropy gives as the randomness of the string computed as $H = - \sum p(x) log(p(x))$
 

#!csharp

public double ComputeEntropy(string message)
{
    Dictionary<char, int> K = message.GroupBy(c => c).ToDictionary(g => g.Key, g => g.Count());
    double entropyValue = 0;
    foreach (var character in K)
    {
        double PR = character.Value / (double) message.Length;
        entropyValue -= PR * Math.Log(PR, 2);
    }
    return entropyValue;
}

#!markdown

# Prepare input data

#!csharp

var artifactServiceCollection = new ArtifactServiceCollection(Assembly.GetAssembly(typeof(ArtifactHttp)));
artifactServiceCollection.AddArtifactFromCsvFiles(@"..\Data");
var artifactServices = artifactServiceCollection.Build();
artifactServices.Services.Select(r => { var s = artifactServices.GetService(r); return $"{s.ArtifactType} [{s.Source}]"; }).Display();

var flowStream = artifactServices.GetService(artifactServiceCollection.GetArtifactTypeByName("flow")).GetStreamable<IpfixArtifact>();                        
var dnsStream =  artifactServices.GetService(artifactServiceCollection.GetArtifactTypeByName("dns")).GetStreamable<ArtifactDns>();
var httpStream = artifactServices.GetService(artifactServiceCollection.GetArtifactTypeByName("http")).GetStreamable<ArtifactHttp>();
var tlsStream = artifactServices.GetService(artifactServiceCollection.GetArtifactTypeByName("tls")).GetStreamable<ArtifactTls>();

display($"Flow count = {GetList(flowStream, e=>e.IsData).Count}");
display($"Dns count = {GetList(dnsStream, e=>e.IsData).Count}");
display($"Http count = {GetList(httpStream, e=>e.IsData).Count}");
display($"Tls count = {GetList(tlsStream, e=>e.IsData).Count}");

#!markdown

# Process input flows

#!markdown

## Pair TLS and DNS records 

For TLS records, the cadidate DNS records are identified. The rationale behind this reasoning is that most the TLS connections starts by querying domain name of the destination endpoint. However this is not always the case. For instance, some queries may be locally cached, or the application connects directly to IP address as their use their own resolution mechanism or directory, e.g., TOR and some system services.   

#!csharp

var tlsDomain = tlsStream.Where(f=>f.SourcePort > f.DestinationPort).LeftOuterJoin(
    dnsStream.AlterEventDuration(t => t + TimeSpan.FromMinutes(30).Ticks),  
    f => new { HOST = f.SrcIp, DA = f.DstIp },
    f => new { HOST = f.DstIp, DA = f.DnsResponseData }, 
    l => new { TlsFlow = l, ServerName = l.TlsServerName, CommonName = l.TlsSubjectCommonName, DomainName = string.Empty, Entropy = ComputeEntropy(l.TlsServerName) }, 
    (l,r) => new { TlsFlow = l, ServerName = l.TlsServerName, CommonName = l.TlsSubjectCommonName, DomainName = r.DnsQuestionName, Entropy = ComputeEntropy(l.TlsServerName)}); 

GetList(tlsDomain.GroupApply(t =>"Flows", g=>g.HoppingWindowLifetime(TimeSpan.FromMinutes(5).Ticks, TimeSpan.FromMinutes(5).Ticks).Count(), (k,v) => new {Flows = v} ), e=>e.IsInterval || e.IsEnd).TakeLast(10).Display()

#!csharp

GetList(tlsStream.Where(f => f.TlsServerName.Contains("zvy")), e=>e.IsData).Display()

#!markdown

## TOR handshakes

Using a simple (heuristic) rules we try to identify the TOR related TLS handshakes:

* Generated server name, which means that Entropy is rather high (TODO: here we can also use ngrams for improve the precision) as some regular names can also have quite high entropy
* TLS Common name is missing, which is not the case for all TOR connections but a significat amount of exit nodes just does not provide this information.
* Empty domain name, as there is not DNS resolution associated with this connection

#!csharp

var torHandshakes = tlsDomain.Where(e=> String.IsNullOrWhiteSpace(e.DomainName) && e.CommonName == "N/A" && e.Entropy > 3);
// GetList(torHandshakes, e=>e.IsInterval || e.IsEnd).OrderByDescending(e=>e.Payload.Entropy).Display();
var exitNodes = torHandshakes.Select(f => new { DA = f.TlsFlow.DstIp, DP = f.TlsFlow.DstPt, ServerName = f.ServerName, JA3 = f.TlsFlow.Ja3Fingerprint } ).HoppingWindowLifetime(TimeSpan.FromMinutes(30).Ticks, (TimeSpan.FromMinutes(10).Ticks));
GetList(exitNodes, e=>e.IsData).Display();

#!markdown

## Identify other TOR exit nodes

As a Tor client still uses the same cipher suites in the handshake with all end points, it is possible to identify other exit nodes. 
 

#!csharp

var allExitNodes  = exitNodes.AlterEventDuration(d => TimeSpan.FromMinutes(60).Ticks).Join(tlsStream.AlterEventDuration(d => TimeSpan.FromMinutes(60).Ticks).Where(f=>f.SourcePort > f.DestinationPort),
    l => l.JA3,
    r => r.Ja3Fingerprint,
    (l,r) => new { DA = r.DstIp, DP = r.DstPt, JA3 = l.JA3, TS = r.FirstSeen }
);
GetList(allExitNodes, e=>e.IsInterval).Display()

#!markdown

## Identify the individual flows as TOR

As we have identified TOR exit nodes, we can match the corresponding TCP flows.

#!csharp

var allTorFlowStream = allExitNodes.Join(flowStream.AlterEventDuration(TimeSpan.FromMinutes(60).Ticks),
        l => new { DA = l.DA, DP = l.DP },
        r => new { DA = r.DstIp, DP = r.DstPt },
        (l,r) => new { Flow = r, Class  = "TOR" } 
    );

   
GetList(allTorFlowStream.Distinct(), e=>e.IsEnd).Display()  
    

#!markdown

# Issues

Handling time!

the problem is with the validity of the events:

- when searching for surrounding TOR flows, we need to define the temproal window large enough to include the relevant flows!
